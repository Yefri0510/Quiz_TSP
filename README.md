# Quiz_TSP
## Yefri Stiven Barrero Solano - 2320392
El código proporcionado implementa un algoritmo genético para resolver el Problema del Viajero (TSP, por sus siglas en inglés), un clásico problema de optimización combinatoria que busca encontrar la ruta más corta posible para visitar un conjunto de ciudades exactamente una vez y regresar al punto de partida. Inspirado en procesos evolutivos naturales como la selección natural y la reproducción, este enfoque utiliza una población de soluciones candidatas (representadas como permutaciones de ciudades) que evolucionan a lo largo de generaciones mediante operaciones de selección, cruce y mutación, con el objetivo de minimizar la distancia total recorrida. El código está escrito en Python, utiliza bibliotecas estándar como random y math para generar aleatoriedad y calcular distancias euclidianas, y define ocho ciudades con coordenadas bidimensionales para simular un mapa simple, permitiendo una ejecución rápida y demostración del concepto sin necesidad de datos reales complejos.

El script comienza con la definición de un diccionario llamado ciudades, que almacena las ocho ciudades etiquetadas de 'A' a 'H' junto con sus coordenadas (x, y) en un plano cartesiano, como 'A' en (0,0) y 'H' en (9,9), lo que facilita el cálculo de distancias euclidianas entre pares de puntos. Esta estructura de datos actúa como la base para representar el grafo completo del problema, donde cada ciudad es un nodo y las aristas tienen pesos basados en la distancia recta. A continuación, se define la función distancia_ruta, que toma una lista de ciudades representando una ruta y calcula su longitud total sumando las distancias euclidianas entre ciudades consecutivas; para cerrar el ciclo del TSP, utiliza el operador módulo % para conectar la última ciudad de vuelta a la primera, iterando sobre el índice de la ruta y extrayendo las coordenadas del diccionario para aplicar la fórmula de Pitágoras mediante math.sqrt, acumulando el resultado en una variable total que se retorna al final.

Para inicializar el proceso evolutivo, la función crear_poblacion_inicial genera una población inicial de rutas aleatorias, donde el parámetro tam_poblacion indica el número de individuos (soluciones) a crear; convierte las claves del diccionario ciudades en una lista, la copia para cada individuo y la baraja aleatoriamente con random.shuffle, asegurando que cada ruta sea una permutación única de todas las ciudades sin repeticiones, lo que preserva la validez de las soluciones para el TSP. Esta población diversa proporciona el punto de partida para la evolución, simulando una variedad genética inicial que el algoritmo refinará con el tiempo.

La selección de individuos para la siguiente generación se maneja en la función seleccion mediante un método de torneo: con un tamaño de torneo fijo de 3, selecciona aleatoriamente grupos de candidatos emparejando cada ruta con su distancia calculada previamente, elige al ganador como aquel con la menor distancia (usando min y una lambda para acceder al segundo elemento del par), y repite el proceso para generar una nueva lista de seleccionados, copiando las rutas ganadoras para evitar modificaciones accidentales. Este enfoque favorece a las rutas más cortas, imitando la supervivencia del más apto, pero introduce algo de aleatoriedad para mantener la diversidad y evitar convergencia prematura.

El cruce, implementado en la función cruce, aplica el operador de cruce ordenado (Order Crossover o OX), una técnica específica para problemas de permutación como el TSP que preserva el orden relativo de elementos; selecciona dos puntos de corte aleatorios (inicio y fin) en la longitud de la ruta, copia el segmento entre ellos del primer padre directamente al hijo en las mismas posiciones, inicializando el resto con None, y luego llena las posiciones restantes comenzando después del segmento, recorriendo cíclicamente el segundo padre e insertando solo las ciudades que no estén ya presentes en el hijo, avanzando tanto en el hijo como en el padre hasta completar la permutación sin duplicados. Este método genera dos hijos por par de padres (uno desde cada perspectiva), aunque la función retorna solo uno, y es crucial para combinar características prometedoras de rutas parentales manteniendo la integridad del problema.

La mutación se realiza en la función mutacion con una probabilidad dada por tasa_mutacion, copiando la ruta de entrada para no alterarla in situ; si un número aleatorio es menor que la tasa, selecciona dos índices aleatorios distintos en la ruta y los intercambia, introduciendo variación local que puede ayudar a escapar de óptimos locales sin destruir completamente la estructura de una buena solución, un equilibrio esencial en algoritmos genéticos para explorar el espacio de búsqueda.

Finalmente, la función principal algoritmo_genético orquesta todo el proceso evolutivo con parámetros por defecto de 100 individuos, 1000 generaciones y una tasa de mutación del 10%; inicia creando la población inicial y variables para rastrear la mejor ruta y distancia encontrada (inicialmente infinito), luego en un bucle por generaciones calcula las distancias de toda la población, actualiza la mejor solución si se encuentra una más corta, aplica la selección para formar una nueva población, realiza cruces en pares consecutivos con una probabilidad del 80% para generar descendientes, aplica mutación a toda la nueva población y la reemplaza como base para la siguiente iteración. Al finalizar, retorna la mejor ruta y su distancia. El bloque if name == "main" ejecuta el algoritmo con parámetros predeterminados, imprimiendo la ruta óptima encontrada y su distancia redondeada a dos decimales, proporcionando una salida simple para verificar el resultado de la optimización. En conjunto, este código demuestra una implementación efectiva y educativa de un algoritmo genético para el TSP, adaptable para instancias más grandes con ajustes en los parámetros o representaciones de ciudades.
